# email_notifier.py

import os
import re
import glob
import json
import logging
import smtplib
from typing import List, Optional, Dict, Tuple
from datetime import datetime, timedelta
from pathlib import Path
import zipfile

import pandas as pd

from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
from email.utils import formataddr

__all__ = ["EnhancedEmailSystem", "EmailNotifier"]


class EnhancedEmailSystem:
    """Email system that assembles a reports+invoices ZIP and sends it with a professional HTML body."""

    def __init__(self, smtp_server=None, smtp_port=None, username=None, password=None):
        # Prefer SMTP_* secrets; fallback to EMAIL_*
        self.smtp_server = smtp_server or os.getenv("SMTP_HOST") or os.getenv("SMTP_SERVER", "smtp.office365.com")
        self.smtp_port = int(smtp_port or os.getenv("SMTP_PORT", "587"))
        self.username = username or os.getenv("SMTP_USER") or os.getenv("EMAIL_USERNAME")
        self.password = password or os.getenv("SMTP_PASS") or os.getenv("EMAIL_PASSWORD")

        # Recipients configuration with validation
        recipients_str = (
            os.getenv("AP_TEAM_EMAIL_LIST")
            or os.getenv("EMAIL_RECIPIENTS")
            or os.getenv("TEAM_EMAIL_LIST")
            or ""
        )
        self.default_recipients = self._validate_email_list(recipients_str) if recipients_str else []

        # Attachment size cap (MB) to keep emails deliverable
        self.max_zip_bytes = int(os.getenv("EMAIL_MAX_ZIP_MB", "24")) * 1024 * 1024

        # Logger
        self.logger = logging.getLogger(__name__)

    # ---------- HTML body ----------

    def create_professional_html_template(self, validation_data: dict, deadline_date: datetime) -> str:
        critical_count = validation_data.get("failed", 0)
        warning_count = validation_data.get("warnings", 0)
        passed_count = validation_data.get("passed", 0)
        total_count = critical_count + warning_count + passed_count
        pass_rate = (passed_count / total_count * 100) if total_count > 0 else 0

        critical_amount = "‚Çπ1,50,000"
        warning_amount = "‚Çπ1,40,000"

        return f"""<!DOCTYPE html>
<html>
  <body style="font-family: Arial, sans-serif; color:#111;">
    <h2>üè¢ KOENIG INVOICE VALIDATION REPORT</h2>
    <p>Automated Processing Summary - {datetime.now().strftime('%B %d, %Y')}</p>

    <h3>üìä EXECUTIVE SUMMARY</h3>
    <p>Processing Rate: <b>{pass_rate:.1f}%</b> ({passed_count}/{total_count} invoices processed successfully)</p>

    <table border="1" cellpadding="6" cellspacing="0">
      <tr><th>Status</th><th>Count</th><th>Financial Impact</th></tr>
      <tr><td>üö® CRITICAL ISSUES</td><td>{critical_count}</td><td>{critical_amount}</td></tr>
      <tr><td>‚ö†Ô∏è WARNING ITEMS</td><td>{warning_count}</td><td>{warning_amount}</td></tr>
      <tr><td>‚úÖ SUCCESSFULLY PROCESSED</td><td>{passed_count}</td><td>Ready for Payment</td></tr>
    </table>

    <h3>üö® IMMEDIATE ACTION REQUIRED</h3>
    <p>Response Deadline: <b>{deadline_date.strftime('%B %d, %Y at %I:%M %p IST')}</b></p>

    <h3>üìé ATTACHMENTS INCLUDED</h3>
    <ul>
      <li>Validation Report (formatted as requested)</li>
      <li>Real invoice files (as many as fit within email size limits)</li>
      <li>Other run reports</li>
    </ul>

    <hr/>
    <p>Koenig Solutions Pvt. Ltd. | Generated by Invoice Management System</p>
    <p style="color:#555;">This is an automated report containing confidential information</p>
  </body>
</html>"""

    # ---------- Helpers ----------

    def _validate_email_list(self, recipients_str: str) -> List[str]:
        """Validate and clean email recipient list (comma/semicolon separated)"""
        email_pattern = re.compile(r"^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$")
        emails: List[str] = []
        for raw in recipients_str.replace(";", ",").split(","):
            email = raw.strip()
            if not email:
                continue
            if email_pattern.match(email):
                emails.append(email)
            else:
                self.logger.warning(f"Invalid email format ignored: {email}")
        return emails

    def _today_dir_guess(self) -> Optional[Path]:
        data_root = Path("data")
        if not data_root.exists():
            return None
        today = datetime.now().strftime("%Y-%m-%d")
        td = data_root / today
        if td.exists():
            return td
        dated = [p for p in data_root.iterdir() if p.is_dir()]
        return max(dated, key=lambda p: p.stat().st_mtime) if dated else None

    def _read_latest_rms_table(self) -> Optional[pd.DataFrame]:
        """Load the tab-separated RMS export (invoice_download.xls) as DataFrame of strings."""
        ddir = self._today_dir_guess()
        if ddir:
            tsv_path = ddir / "invoice_download.xls"
            if tsv_path.exists():
                try:
                    return pd.read_csv(tsv_path, sep="\t", dtype=str, engine="python")
                except Exception as e:
                    self.logger.warning(f"Could not read TSV from {tsv_path}: {e}")
        candidates = glob.glob("data/*/invoice_download.xls")
        if candidates:
            latest = max(candidates, key=os.path.getctime)
            try:
                return pd.read_csv(latest, sep="\t", dtype=str, engine="python")
            except Exception as e:
                self.logger.warning(f"Could not read TSV from {latest}: {e}")
        return None

    def _read_latest_detailed_validation(self) -> Optional[pd.DataFrame]:
        """Try to load the detailed validation output to pull Validation_Status / Issue_Details."""
        paths = glob.glob("data/invoice_validation_detailed_*.xlsx") or []
        if not paths:
            return None
        latest = max(paths, key=os.path.getctime)
        try:
            return pd.read_excel(latest)
        except Exception as e:
            self.logger.warning(f"Could not read detailed validation workbook: {latest}: {e}")
            return None

    def _safe_get(self, row: Dict[str, str], names: List[str]) -> Optional[str]:
        """Case-insensitive lookup from a row-dict; returns first non-empty value among candidates."""
        lower_map = {k.lower(): k for k in row.keys()}
        for name in names:
            key = lower_map.get(name.lower())
            if key:
                v = row.get(key)
                if pd.notna(v) and str(v).strip() != "":
                    return str(v).strip()
        return None

    def _num(self, x) -> float:
        try:
            s = str(x).replace(",", "").strip()
            return float(s) if s not in ("", "None", "nan") else 0.0
        except Exception:
            return 0.0

    # ---------- Creator enrichment ----------

    def _select_column(self, df: pd.DataFrame, candidates: List[str]) -> Optional[str]:
        lmap = {c.lower(): c for c in df.columns}
        for cand in candidates:
            if cand.lower() in lmap:
                return lmap[cand.lower()]
        # fuzzy contains
        for c in df.columns:
            lc = c.lower()
            if any(tok.lower() in lc for tok in candidates):
                return c
        return None

    def _load_creator_lookup_from_df(self, df: pd.DataFrame) , str]:
        """Try to detect invoice number column and creator column in an arbitrary dataframe."""
        inv_col = self._select_column(
            df,
            [
                "PurchaseInvNo","Invoice Number","Invoice_Number","InvoiceNumber",
                "VoucherNo","InvID","RMS_Invoice_ID"
            ],
        )
        creator_col = self._select_column(
            df,
            [
                "Inv Created By","Invoice_Creator_Name","Creator","CreatedBy",
                "Created By","Inv_Created_By","Invoice Created By"
            ],
        )
        lookup: Dict[str, str] = {}
        if inv_col and creator_col:
            for _, r in df[[inv_col, creator_col]].dropna().iterrows():
                inv = str(r[inv_col]).strip()
                cr = str(r[creator_col]).strip()
                if inv and cr:
                    lookup[inv] = self._clean_creator(cr)
        return lookup

    def _clean_creator(self, name: str) -> str:
        s = re.sub(r"\s*\(.*\)$", "", str(name)).strip()
        if not s or s.lower() in {"n/a","na","null","none","unknown","system"}:
            return "System Generated"
        return s.title()

    def _build_creator_lookup(self, df_rms: pd.DataFrame) -> Dict[str, str]:
        """Aggregate creator mapping from multiple sources (RMS TSV, validation_result, creator files)."""
        lookup: Dict[str, str] = {}

        # 1) RMS TSV itself
        try:
            lookup.update(self._load_creator_lookup_from_df(df_rms))
        except Exception as e:
            self.logger.debug(f"Creator from RMS TSV failed: {e}")

        # 2) validation_result.xlsx under the run dir
        try:
            ddir = self._today_dir_guess()
            if ddir:
                valres = ddir / "validation_result.xlsx"
                if valres.exists():
                    df = pd.read_excel(valres)
                    lookup.update(self._load_creator_lookup_from_df(df))
        except Exception as e:
            self.logger.debug(f"Creator from validation_result.xlsx failed: {e}")

        # 3) Any obvious creator mapping files in run dir (csv/xlsx/json)
        try:
            ddir = self._today_dir_guess()
            if ddir:
                patterns = ["*creator*.csv","*created*by*.csv","*creator*.xlsx","*created*by*.xlsx","*creator*.json","*created*by*.json"]
                paths: List[Path] = []
                for pat in patterns:
                    paths += list(ddir.glob(pat))
                for p in paths:
                    try:
                        if p.suffix.lower() == ".csv":
                            df = pd.read_csv(p, dtype=str)
                            lookup.update(self._load_creator_lookup_from_df(df))
                        elif p.suffix.lower() in {".xlsx",".xls"}:
                            df = pd.read_excel(p, dtype=str)
                            lookup.update(self._load_creator_lookup_from_df(df))
                        elif p.suffix.lower() == ".json":
                            try:
                                obj = json.loads(p.read_text(encoding="utf-8"))
                                if isinstance(obj, dict):
                                    # assume {"INV-...": "Name", ...}
                                    for k, v in obj.items():
                                        if k and v:
                                            lookup[str(k).strip()] = self._clean_creator(v)
                                elif isinstance(obj, list):
                                    # list of records
                                    df = pd.DataFrame(obj)
                                    lookup.update(self._load_creator_lookup_from_df(df))
                            except Exception as je:
                                self.logger.debug(f"Creator JSON parse failed ({p}): {je}")
                    except Exception as ie:
                        self.logger.debug(f"Creator map load failed ({p}): {ie}")
        except Exception as e:
            self.logger.debug(f"Creator glob failed: {e}")

        if lookup:
            self.logger.info(f"Creator lookup built with {len(lookup)} entries")
        else:
            self.logger.warning("No creator info sources found; Invoice_Creator_Name may be Unknown")
        return lookup

    # ---------- Report builder (requested format) ----------

    def build_formatted_validation_report(self) -> Optional[str]:
        """
        Build Excel at data/validation_report_formatted_YYYY-MM-DD.xlsx
        with the requested column order, using best-effort field mapping from RMS export
        plus detailed validation outputs and enriched creator mapping.
        """
        df_rms = self._read_latest_rms_table()
        if df_rms is None or df_rms.empty:
            self.logger.error("No RMS table found to build formatted validation report.")
            return None

        # Map detailed validation by invoice number (best effort)
        detail = self._read_latest_detailed_validation()
        validation_lookup = {}
        if detail is not None and not detail.empty:
            cols_lower = {c.lower(): c for c in detail.columns}
            inv_col = cols_lower.get("invoice number") or cols_lower.get("invoice_number") or cols_lower.get("purchaseinvno") or None
            status_col = cols_lower.get("validation status") or cols_lower.get("validation_status") or cols_lower.get("validation result") or cols_lower.get("validation_result")
            issues_col = cols_lower.get("issues_found") or cols_lower.get("error details") or cols_lower.get("error_details")
            if inv_col is not None:
                for _, r in detail.iterrows():
                    key = str(r.get(inv_col, "")).strip()
                    if key:
                        validation_lookup[key] = {
                            "Validation_Status": str(r.get(status_col, "")).strip() if status_col else "",
                            "Issues_Found": str(r.get(issues_col, "")).strip() if issues_col else "",
                            "Issue_Details": str(r.get(issues_col, "")).strip() if issues_col else "",
                        }

        # Build creator lookup from multiple sources (RMS/validation_result/creator maps)
        creator_lookup = self._build_creator_lookup(df_rms)

        # Requested columns (duplicate "Location" kept; fixed Total_Tax_Calculated name)
        columns = [
            "Invoice_ID",
            "Invoice_Number",
            "Invoice_Date",
            "Invoice_Entry_Date",
            "Vendor_Name",
            "Amount",
            "Invoice_Creator_Name",
            "Location",
            "Invoice currency",
            "Method_of_Payment",
            "Account_Head",
            "Validation_Status",
            "Issues_Found",
            "Issue_Details",
            "GST_Number",
            "Row_Index",
            "Validation_Date",
            "Invoice_Currency",
            "Location",  # duplicate
            "Tax_Type",
            "Due_Date",
            "Due_Date_Notification",
            "Total_Tax_Calculated",
            "CGST_Amount",
            "SGST_Amount",
            "IGST_Amount",
            "VAT_Amount",
            "TDS_Status",
            "RMS_Invoice_ID",
            "SCID",
        ]

        out_rows: List[List[Optional[str]]] = []
        df_rms = df_rms.fillna("")
        for idx, r in df_rms.iterrows():
            row = r.to_dict()

            invoice_no = self._safe_get(row, ["PurchaseInvNo","Invoice Number","Invoice_No","InvoiceNumber","VoucherNo"]) or ""
            vendor = self._safe_get(row, ["PartyName","Vendor Name","Vendor_Name"]) or ""
            inv_date = self._safe_get(row, ["PurchaseInvDate","Invoice Date","Voucherdate"]) or ""
            entry_date = self._safe_get(row, ["Voucherdate","Invoice_Entry_Date"]) or inv_date
            amount = self._safe_get(row, ["Total","Amount","PaytyAmt","TaxableValue"]) or ""
            # Try many creator headers; if still blank, use lookup
            creator = (
                self._safe_get(row, [
                    "Inv Created By","Invoice_Creator_Name","Creator","CreatedBy","Created By","Inv_Created_By","Invoice Created By"
                ]) or creator_lookup.get(invoice_no, "Unknown")
            )
            creator = self._clean_creator(creator)

            location = self._safe_get(row, ["State","Location"]) or ""
            currency = self._safe_get(row, ["Currency","Invoice currency","Invoice_Currency"]) or ""
            method = self._safe_get(row, ["Method_of_Payment","Payment Method"]) or ""
            account_head = self._safe_get(row, ["PurchaseLEDGER","Account_Head","Narration"]) or ""
            gst = self._safe_get(row, ["GSTNO","GST_Number","GSTIN"]) or ""
            rms_id = self._safe_get(row, ["InvID","RMS_Invoice_ID"]) or ""
            scid = self._safe_get(row, ["SCID"]) or ""
            due_date = self._safe_get(row, ["Due_Date","Due Date"]) or ""
            due_note = self._safe_get(row, ["Due_Date_Notification"]) or ""

            cgst = self._num(self._safe_get(row, ["CGSTInputAmt","CGST_Amount"]) or 0)
            sgst = self._num(self._safe_get(row, ["SGSTInputAmt","SGST_Amount"]) or 0)
            igst = self._num(self._safe_get(row, ["IGST/VATInputAmt","IGST_Amount","IGSTInputAmt"]) or 0)
            vat = self._num(self._safe_get(row, ["VAT","VAT_Amount"]) or 0)
            total_tax = cgst + sgst + igst + vat

            if igst > 0:
                tax_type = "IGST"
            elif (cgst + sgst) > 0:
                tax_type = "GST"
            elif vat > 0:
                tax_type = "VAT"
            else:
                tax_type = ""

            tds_raw = self._safe_get(row, ["TDS","TDS_Status"])
            tds_status = "Deducted" if self._num(tds_raw) > 0 else (str(tds_raw) if tds_raw not in (None, "", "0", "0.0") else "Not Deducted")

            v_status = ""
            issues_found = ""
            issue_details = ""
            if invoice_no and invoice_no in validation_lookup:
                got = validation_lookup[invoice_no]
                v_status = got.get("Validation_Status", "") or ""
                issues_found = got.get("Issues_Found", "") or ""
                issue_details = got.get("Issue_Details", "") or ""

            values = [
                rms_id,                     # Invoice_ID
                invoice_no,                 # Invoice_Number
                inv_date,                   # Invoice_Date
                entry_date,                 # Invoice_Entry_Date
                vendor,                     # Vendor_Name
                amount,                     # Amount
                creator,                    # Invoice_Creator_Name
                location,                   # Location
                currency,                   # Invoice currency
                method,                     # Method_of_Payment
                account_head,               # Account_Head
                v_status,                   # Validation_Status
                issues_found,               # Issues_Found
                issue_details,              # Issue_Details
                gst,                        # GST_Number
                idx,                        # Row_Index
                datetime.now().strftime("%Y-%m-%d"),  # Validation_Date
                currency,                   # Invoice_Currency
                location,                   # Location (duplicate requested)
                tax_type,                   # Tax_Type
                due_date,                   # Due_Date
                due_note,                   # Due_Date_Notification
                total_tax,                  # Total_Tax_Calculated
                cgst,                       # CGST_Amount
                sgst,                       # SGST_Amount
                igst,                       # IGST_Amount
                vat,                        # VAT_Amount
                tds_status,                 # TDS_Status
                rms_id,                     # RMS_Invoice_ID
                scid,                       # SCID
            ]
            out_rows.append(values)

        out_df = pd.DataFrame(out_rows, columns=columns)

        out_path = Path("data") / f"validation_report_formatted_{datetime.now().strftime('%Y-%m-%d')}.xlsx"
        out_path.parent.mkdir(parents=True, exist_ok=True)
        try:
            with pd.ExcelWriter(out_path, engine="xlsxwriter") as writer:
                out_df.to_excel(writer, index=False, sheet_name="Validation Report")
            self.logger.info(f"Formatted validation report written: {out_path}")
            return str(out_path)
        except Exception as e:
            self.logger.error(f"Failed to write formatted validation report: {e}")
            return None

    # ---------- ZIP assembly (reports + real invoices) ----------

    def _add_file_if_fits(self, zipf: zipfile.ZipFile, path: str, arcname: str, running_size: int) -> int:
        try:
            sz = os.path.getsize(path)
        except OSError:
            return running_size
        if running_size + sz > self.max_zip_bytes:
            self.logger.warning(f"Skipping (limit): {path} ({sz} bytes)")
            return running_size
        zipf.write(path, arcname=arcname)
        return running_size + sz

    def _add_invoices_from_inner_zip(self, outer: zipfile.ZipFile, inner_zip_path: str, running_size: int) -> int:
        try:
            with zipfile.ZipFile(inner_zip_path, "r") as inner:
                for info in sorted(inner.infolist(), key=lambda i: i.filename):
                    if info.is_dir():
                        continue
                    fname = info.filename
                    ext = os.path.splitext(fname)[1].lower()
                    if ext not in (".pdf", ".png", ".jpg", ".jpeg"):
                        continue
                    fsize = info.file_size or 0
                    if running_size + fsize > self.max_zip_bytes:
                        self.logger.warning(f"Skipping invoice (limit): {fname} ({fsize} bytes)")
                        break
                    data = inner.read(info.filename)
                    outer.writestr(f"invoices/{os.path.basename(fname)}", data)
                    running_size += len(data)
        except Exception as e:
            self.logger.warning(f"Could not extract invoices from {inner_zip_path}: {e}")
        return running_size

    def create_invoice_zip(self) -> Optional[str]:
        # Ensure new formatted report exists (and enriched with creator)
        self.build_formatted_validation_report()

        zip_filename: Optional[str] = None
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            zip_filename = f"invoice_validation_{timestamp}.zip"

            candidates: List[str] = []
            candidates += glob.glob("invoice_validation_report_*.xlsx")          # legacy report
            candidates += glob.glob("data/validation_report_formatted_*.xlsx")   # new requested format
            candidates += glob.glob("data/invoice_validation_detailed_*.xlsx")
            candidates += glob.glob("data/*/validation_result.xlsx")
            candidates += glob.glob("data/delta_report_*.xlsx")
            candidates += glob.glob("data/email_summary_*.html")

            invoice_zips = glob.glob("data/*/invoices.zip") + glob.glob("invoices.zip")
            newest_invoices_zip = max(invoice_zips, key=os.path.getctime) if invoice_zips else None

            running_size = 0
            with zipfile.ZipFile(zip_filename, "w", zipfile.ZIP_DEFLATED) as zipf:
                for path in sorted(set(candidates)):
                    if not os.path.isfile(path):
                        continue
                    base = os.path.basename(path)
                    arc = f"reports/{base}"
                    before = running_size
                    running_size = self._add_file_if_fits(zipf, path, arc, running_size)
                    if running_size != before:
                        self.logger.info(f"Added report: {path} -> {arc}")

                if newest_invoices_zip and os.path.isfile(newest_invoices_zip):
                    running_size = self._add_invoices_from_inner_zip(zipf, newest_invoices_zip, running_size)
                else:
                    self.logger.warning("No invoices.zip found to include real invoices.")

            if os.path.exists(zip_filename) and os.path.getsize(zip_filename) > 0:
                self.logger.info(f"ZIP created successfully: {zip_filename} ({os.path.getsize(zip_filename)} bytes)")
                return zip_filename

            self.logger.error("ZIP file creation failed or file is empty")
            return None

        except Exception as e:
            self.logger.error(f"Error creating ZIP: {e}")
            if zip_filename and os.path.exists(zip_filename):
                try:
                    os.remove(zip_filename)
                except Exception:
                    pass
            return None

    # ---------- Email sender ----------

    def _split_emails(self, raw: Union[str, List[str], None]) -> List[str]:
    if not raw:
        return []
    if isinstance(raw, list):
        parts = raw
    else:
        parts = re.split(r'[;,]', raw)
    cleaned = []
    for p in parts:
        e = p.strip()
        if e:
            cleaned.append(e)
    return cleaned

def send_email(self, to_emails: Union[str, List[str]], subject: str,
               body_text: str, body_html: str = None, 
               cc_emails: Union[str, List[str]] = None,
               attachments: List[str] = None) -> bool:
    try:
        to_list = self._split_emails(to_emails)
        cc_list = self._split_emails(cc_emails)

        if not to_list:
            self.logger.error("No valid TO recipients configured")
            return False

        # Root must be multipart/mixed for attachments
        root = MIMEMultipart('mixed')
        root['From'] = self.from_email or self.username
        root['To'] = ', '.join(to_list)
        if cc_list:
            root['Cc'] = ', '.join(cc_list)
        root['Subject'] = subject or "Invoice Validation Report"
        # Optional: improve reply path
        if self.from_email:
            root['Reply-To'] = self.from_email

        # Build the alternative part (text + html)
        alt = MIMEMultipart('alternative')
        alt.attach(MIMEText(body_text or "(no text body)", 'plain', 'utf-8'))
        if body_html:
            alt.attach(MIMEText(body_html, 'html', 'utf-8'))
        root.attach(alt)

        # Attach files
        if attachments:
            for attachment in attachments:
                if os.path.exists(attachment) and os.path.isfile(attachment):
                    with open(attachment, 'rb') as f:
                        part = MIMEBase('application', 'octet-stream')
                        part.set_payload(f.read())
                    encoders.encode_base64(part)
                    filename = os.path.basename(attachment)
                    part.add_header('Content-Disposition', f'attachment; filename="{filename}"')
                    root.attach(part)
                    self.logger.info(f"Added attachment: {filename}")

        all_recipients = to_list + cc_list

        with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
            server.ehlo()
            server.starttls()
            server.ehlo()
            server.login(self.username, self.password)
            server.send_message(root, to_addrs=all_recipients)

        self.logger.info(f"Production email sent successfully to {len(all_recipients)} recipients")
        return True

    except Exception as e:
        self.logger.error(f"Failed to send production email: {e}")
        return False

    def validate_email_config(self) -> List[str]:
        issues: List[str] = []
        if not self.username:
            issues.append("Missing SMTP_USER (or EMAIL_USERNAME) environment variable")
        if not self.password:
            issues.append("Missing SMTP_PASS (or EMAIL_PASSWORD) environment variable")
        if not self.default_recipients:
            issues.append("No valid email recipients configured")
        if not self.smtp_server:
            issues.append("Missing SMTP server configuration")
        return issues

class EmailNotifier:
    """
    Compatibility wrapper around EnhancedEmailSystem so existing code can:
        from email_notifier import EmailNotifier
    and then call: send / send_report / send_validation_email / send_validation_report
    """

    def __init__(
        self,
        smtp_host: Optional[str] = None,
        smtp_port: Optional[int] = None,
        smtp_user: Optional[str] = None,
        smtp_pass: Optional[str] = None,
        use_tls: Optional[bool] = None,  # kept for API symmetry; STARTTLS is used by default
        from_name: Optional[str] = None,
        recipients: Optional[List[str]] = None,
    ):
        host = smtp_host or os.getenv("SMTP_HOST") or os.getenv("SMTP_SERVER", "smtp.office365.com")
        port = int(smtp_port or os.getenv("SMTP_PORT", "587"))
        user = smtp_user or os.getenv("SMTP_USER") or os.getenv("EMAIL_USERNAME")
        pwd = smtp_pass or os.getenv("SMTP_PASS") or os.getenv("EMAIL_PASSWORD")

        self._engine = EnhancedEmailSystem(
            smtp_server=host,
            smtp_port=port,
            username=user,
            password=pwd,
        )
        self._from_name = from_name or os.getenv("SMTP_FROM_NAME", "")

        if recipients:
            validated: List[str] = []
            src = recipients if isinstance(recipients, list) else [recipients]
            for r in src:
                validated.extend(self._engine._validate_email_list(str(r)))
            if validated:
                self._engine.default_recipients = validated

    def _zip_attachments_if_needed(self, attachments) -> Optional[str]:
        if attachments is None:
            return None

        if isinstance(attachments, (str, os.PathLike)):
            s = str(attachments)
            if s.lower().endswith(".zip") and os.path.isfile(s):
                return s
            if os.path.isfile(s):
                ts = datetime.now().strftime("%Y%m%d_%H%M%S")
                zip_path = f"email_attachments_{ts}.zip"
                try:
                    with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zf:
                        zf.write(s, arcname=os.path.basename(s))
                    return zip_path
                except Exception as e:
                    logging.error(f"EmailNotifier: Failed to bundle single attachment: {e}")
                    try:
                        if os.path.exists(zip_path):
                            os.remove(zip_path)
                    except Exception:
                        pass
                    return None
            logging.warning("EmailNotifier: attachments is a string but not a file path; ignoring.")
            return None

        if isinstance(attachments, list):
            paths = [str(p) for p in attachments if isinstance(p, (str, os.PathLike))]
            if not paths:
                return None
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
            zip_path = f"email_attachments_{ts}.zip"
            try:
                with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zf:
                    for p in paths:
                        if os.path.isfile(p):
                            zf.write(p, arcname=os.path.basename(p))
                return zip_path if os.path.getsize(zip_path) > 0 else None
            except Exception as e:
                logging.error(f"EmailNotifier: Failed to bundle attachments list: {e}")
                try:
                    if os.path.exists(zip_path):
                        os.remove(zip_path)
                except Exception:
                    pass
                return None

        logging.warning(f"EmailNotifier: attachments of unsupported type {type(attachments).__name__}; ignoring.")
        return None

    def send(self, subject: str, html_body, attachments=None, recipients: Optional[List[str]] = None, from_email: Optional[str] = None) -> bool:
        if recipients:
            validated: List[str] = []
            src = recipients if isinstance(recipients, list) else [recipients]
            for r in src:
                validated.extend(self._engine._validate_email_list(str(r)))
            if validated:
                self._engine.default_recipients = validated

        zip_file = self._zip_attachments_if_needed(attachments)
        if not zip_file:
            zip_file = self._engine.create_invoice_zip()

        try:
            if zip_file and os.path.getsize(zip_file) > self._engine.max_zip_bytes:
                logging.warning("EmailNotifier: Provided ZIP exceeds size cap; rebuilding under size limit.")
                zip_file = self._engine.create_invoice_zip()
                if zip_file and os.path.getsize(zip_file) > self._engine.max_zip_bytes:
                    logging.warning("EmailNotifier: Could not build a small enough ZIP; sending without attachment.")
                    zip_file = None
        except Exception as _e:
            logging.warning(f"EmailNotifier: size check failed ({_e}); proceeding without attachment.")
            zip_file = None

        return self._engine.send_email_with_attachments(
            self._engine.default_recipients,
            subject,
            html_body,
            zip_file
        )

    # Backward-compatible aliases
    def send_report(self, subject: str, html_body, attachments=None, recipients: Optional[List[str]] = None) -> bool:
        return self.send(subject, html_body, attachments, recipients)

    def send_validation_email(self, subject: str, html_body, attachments=None, recipients: Optional[List[str]] = None) -> bool:
        return self.send(subject, html_body, attachments, recipients)

    def send_validation_report(self, subject: str, html_body, attachments=None, recipients: Optional[List[str]] = None) -> bool:
        return self.send(subject, html_body, attachments, recipients)

# Optional local test
if __name__ == "__main__":
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        handlers=[logging.StreamHandler(), logging.FileHandler("email_system.log")],
    )

    print("üß™ Testing EnhancedEmailSystem configuration...")
    engine = EnhancedEmailSystem()
    issues = engine.validate_email_config()
    if issues:
        print("‚ö†Ô∏è Config issues:")
        for i in issues:
            print("  -", i)
    else:
        print(f"‚úÖ Config OK. Default recipients: {engine.default_recipients}")
        html = engine.create_professional_html_template(
            {"failed": 1, "warnings": 2, "passed": 3},
            datetime.now() + timedelta(days=3),
        )
        z = engine.create_invoice_zip()
        ok = engine.send_email_with_attachments(engine.default_recipients, "Test Email (attachments)", html, z)
        print("Send result:", ok)